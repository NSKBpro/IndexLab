{% extends "base.html" %}
{% block body %}
<h1 class="text-2xl font-semibold mb-6">Evaluation — Comparison</h1>

<section class="bg-white dark:bg-slate-800 rounded-2xl border border-slate-200 dark:border-slate-700 p-6 shadow-sm">
  <div class="grid lg:grid-cols-2 gap-6">
    <!-- Controls -->
    <div class="space-y-4">
      <div class="grid sm:grid-cols-2 gap-4">
        <div>
          <label class="text-sm font-medium">Index A (baseline)</label>
          <select id="index-a" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2"></select>
        </div>
        <div>
          <label class="text-sm font-medium">Hybrid A</label>
          <select id="hybrid-a" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2">
            <option value="">Default</option>
            <option value="true">On</option>
            <option value="false">Off</option>
          </select>
        </div>
        <div>
          <label class="text-sm font-medium">Index B (candidate)</label>
          <select id="index-b" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2"></select>
        </div>
        <div>
          <label class="text-sm font-medium">Hybrid B</label>
          <select id="hybrid-b" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2">
            <option value="">Default</option>
            <option value="true">On</option>
            <option value="false">Off</option>
          </select>
        </div>
      </div>

      <div class="grid sm:grid-cols-3 gap-4 items-end">
        <div>
          <label class="text-sm font-medium">Top-K</label>
          <input id="k" type="number" min="1" max="100" value="10" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2">
        </div>
        <div>
          <label class="text-sm font-medium">Mode</label>
          <select id="mode" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2">
            <option value="same">Same CSV for both</option>
            <option value="different">Separate CSVs</option>
          </select>
        </div>
        <div>
          <label class="text-sm font-medium opacity-0">.</label>
          <button id="run" class="w-full rounded-xl bg-brand-600 hover:bg-brand-700 text-white px-4 py-2 font-medium">Run Comparison</button>
        </div>
      </div>

      <div id="csv-inputs" class="grid sm:grid-cols-2 gap-4">
        <div>
          <label class="text-sm font-medium">CSV (question,expected_id)</label>
          <input id="csv-a" type="file" accept=".csv" class="mt-1 w-full text-sm">
        </div>
        <div id="csv-b-wrap" class="hidden">
          <label class="text-sm font-medium">CSV B (question,expected_id)</label>
          <input id="csv-b" type="file" accept=".csv" class="mt-1 w-full text-sm">
        </div>
      </div>

      <div class="flex flex-wrap items-center gap-3">
        <button id="download" class="rounded-xl border border-slate-300 dark:border-slate-700 px-3 py-2 text-sm">Download Diff CSV</button>
        <div class="ml-auto flex items-center gap-2">
          <label class="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" id="only_changed" class="rounded border" />
            Changed only
          </label>
          <label class="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" id="only_impr" class="rounded border" />
            Improvements
          </label>
          <label class="inline-flex items-center gap-2 text-sm">
            <input type="checkbox" id="only_regr" class="rounded border" />
            Regressions
          </label>
          <input id="filter" placeholder="Filter question/id…" class="rounded-md border px-3 py-2 text-sm">
        </div>
        <div id="status" class="text-sm text-slate-500">—</div>
      </div>
    </div>

    <!-- Metrics -->
    <div class="space-y-4">
      <div id="cards" class="grid sm:grid-cols-3 gap-4"></div>
      <div id="delta" class="grid sm:grid-cols-3 gap-4"></div>
    </div>
  </div>

  <!-- Table -->
  <div class="mt-6 overflow-auto border border-slate-200 dark:border-slate-700 rounded-lg">
    <table class="min-w-full text-sm">
      <thead class="bg-slate-50 dark:bg-slate-900 sticky top-0 z-10">
        <tr>
          <th data-key="question" class="th text-left px-3 py-2 cursor-pointer">Question</th>
          <th data-key="expected_id" class="th text-left px-3 py-2 cursor-pointer">Expected</th>
          <th data-key="left_rank" class="th text-left px-3 py-2 cursor-pointer">Rank A</th>
          <th data-key="left_score" class="th text-left px-3 py-2 cursor-pointer">Score A</th>
          <th data-key="right_rank" class="th text-left px-3 py-2 cursor-pointer">Rank B</th>
          <th data-key="right_score" class="th text-left px-3 py-2 cursor-pointer">Score B</th>
          <th data-key="delta" class="th text-left px-3 py-2 cursor-pointer">Δ Rank (B−A)</th>
          <th data-key="status" class="th text-left px-3 py-2">Status</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>
</section>

<!-- Toast -->
<div id="toast" class="fixed bottom-4 left-1/2 -translate-x-1/2 hidden rounded-xl bg-slate-900 text-white px-4 py-2 shadow-lg"></div>

<script>
// ---------------- utils ----------------
const qs=(s,el=document)=>el.querySelector(s);
const qsa=(s,el=document)=>[...el.querySelectorAll(s)];
const esc=(s)=> (s??'').toString().replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
function toast(msg){ const t=qs('#toast'); t.textContent=msg; t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'),1400); }
const fmtPct=(x)=> (x==null ? '—' : (x*100).toFixed(1)+'%');
const fmtNum=(x, d=3)=> (x==null ? '—' : Number(x).toFixed(d));

// robust index normalization (accept multiple shapes)
function normalizeIndexes(x){
  if (!x) return [];
  let arr=[];
  if (Array.isArray(x)) arr=x;
  else if (Array.isArray(x.indexes)) arr=x.indexes;
  else if (Array.isArray(x.data)) arr=x.data;
  else if (x.items && Array.isArray(x.items)) arr=x.items;
  else if (x.indexes && typeof x.indexes==='object') arr=Object.values(x.indexes);
  return arr.map(it=>{
    if (typeof it==='string') return it;
    if (it && typeof it==='object'){
      return it.index_name || it.name || it.id || it.index || it.title || it.slug;
    }
    return null;
  }).filter(Boolean);
}

// ---------------- fetchers ----------------
async function fetchIndexes(){
  const r = await fetch('/api/indexes');
  const data = await r.json();
  return normalizeIndexes(data);
}

// ---------------- state ----------------
let RAW_ROWS = [];   // data.results
let VIEW = [];       // filtered + sorted view
let SORT = { key: 'delta', dir: 'asc' };

// ---------------- helpers ----------------
function scoreFrom(row, side){
  // Try flexible shapes:
  // 1) row.left_score / row.right_score
  // 2) row.left_scores[] at rank-1
  const rankKey = side+'_rank', scoreKey = side+'_score', scoresKey = side+'_scores';
  const r = row[rankKey];
  if (typeof row[scoreKey] === 'number') return row[scoreKey];
  if (Array.isArray(row[scoresKey]) && r!=null && r>0){
    const v = row[scoresKey][r-1];
    if (typeof v === 'number') return v;
  }
  return null;
}
function statusOf(r){
  if (r.delta == null || r.delta === 0) return 'unchanged';
  return r.delta < 0 ? 'improvement' : 'regression';
}
function rowClass(r){
  const s = statusOf(r);
  if (s==='improvement') return 'bg-emerald-50/60 dark:bg-emerald-900/20';
  if (s==='regression')  return 'bg-rose-50/60 dark:bg-rose-900/20';
  return '';
}
function arrow(v){
  if (v==null || v===0) return '→';
  return v<0 ? '↓' : '↑';
}
function signed(x){
  if (x==null) return '—';
  return (x>0?'+':'') + x;
}
function card(label, value, sub=''){
  return `<div class="rounded-xl border border-slate-200 dark:border-slate-700 p-4 bg-white dark:bg-slate-900/60">
    <div class="text-xs text-slate-500">${esc(label)}</div>
    <div class="text-xl font-semibold mt-1">${value}</div>
    ${sub?`<div class="text-[11px] text-slate-500 mt-1">${esc(sub)}</div>`:''}
  </div>`;
}

// ---------------- render ----------------
function renderCards(payload, aName, bName){
  const A = payload.left || {};
  const B = payload.right || {};
  const total = payload.total ?? (RAW_ROWS?.length || 0);
  const dRecall = (A.recall_at_k!=null && B.recall_at_k!=null) ? (B.recall_at_k - A.recall_at_k) : null;
  const dMRR    = (A.mrr!=null && B.mrr!=null) ? (B.mrr - A.mrr) : null;

  qs('#cards').innerHTML = [
    card('Recall@K (A)', fmtPct(A.recall_at_k), aName),
    card('Recall@K (B)', fmtPct(B.recall_at_k), bName),
    card('Questions', esc(total)),
    card('MRR (A)', fmtNum(A.mrr,3), aName),
    card('MRR (B)', fmtNum(B.mrr,3), bName),
    card('K', esc(payload.k ?? '—'))
  ].join('');

  qs('#delta').innerHTML = [
    card('Δ Recall (B−A)', dRecall==null?'—':((dRecall*100).toFixed(1)+' pp')),
    card('Δ MRR (B−A)', dMRR==null?'—':(dMRR>=0?'+':'')+dMRR.toFixed(3)),
    card('Changed', esc(payload.changed_count ?? (RAW_ROWS.filter(r=>r.delta!=null && r.delta!==0).length)))
  ].join('');
}

function applyFilters(){
  const onlyChanged = qs('#only_changed').checked;
  const onlyImpr = qs('#only_impr').checked;
  const onlyRegr = qs('#only_regr').checked;
  const q = (qs('#filter').value||'').toLowerCase().trim();

  VIEW = RAW_ROWS.filter(r=>{
    const s = statusOf(r);
    if (onlyChanged && s==='unchanged') return false;
    if (onlyImpr && s!=='improvement') return false;
    if (onlyRegr && s!=='regression') return false;
    if (q){
      const hay = [r.question, r.expected_id].join(' ').toLowerCase();
      if (!hay.includes(q)) return false;
    }
    return true;
  });

  const key = SORT.key, dir = SORT.dir;
  VIEW.sort((a,b)=>{
    const getVal=(row)=>{
      if (key==='left_score')  return scoreFrom(row,'left') ?? -Infinity;
      if (key==='right_score') return scoreFrom(row,'right') ?? -Infinity;
      return row[key];
    };
    const av=getVal(a), bv=getVal(b);
    const cmp=()=>{
      if (av==null && bv==null) return 0;
      if (av==null) return -1;
      if (bv==null) return 1;
      if (typeof av==='number' && typeof bv==='number') return av-bv;
      return String(av).localeCompare(String(bv));
    };
    const d=cmp();
    return dir==='asc'? d : -d;
  });
}

function renderTable(){
  applyFilters();
  const aName = qs('#index-a').value, bName = qs('#index-b').value;
  const tbody = qs('#tbody');
  if (!VIEW.length){
    tbody.innerHTML = `<tr><td class="px-3 py-6 text-slate-500" colspan="8">No rows.</td></tr>`;
    return;
  }
  tbody.innerHTML = VIEW.map(r=>{
    const ls = scoreFrom(r,'left');  const rs = scoreFrom(r,'right');
    const s = statusOf(r);
    const sBadge =
      s==='improvement' ? `<span class="text-emerald-800 bg-emerald-100 rounded px-2 py-0.5 text-[11px]">improvement</span>` :
      s==='regression'  ? `<span class="text-rose-800 bg-rose-100 rounded px-2 py-0.5 text-[11px]">regression</span>` :
                          `<span class="text-slate-700 bg-slate-100 rounded px-2 py-0.5 text-[11px]">unchanged</span>`;
    return `
      <tr class="${rowClass(r)}">
        <td class="px-3 py-2 align-top">${esc(r.question||'')}</td>
        <td class="px-3 py-2 align-top font-mono text-xs">${esc(r.expected_id||'')}</td>
        <td class="px-3 py-2 align-top">${r.left_rank ?? '—'}</td>
        <td class="px-3 py-2 align-top">${ls==null?'—':ls.toFixed(4)}</td>
        <td class="px-3 py-2 align-top">${r.right_rank ?? '—'}</td>
        <td class="px-3 py-2 align-top">${rs==null?'—':rs.toFixed(4)}</td>
        <td class="px-3 py-2 align-top">${signed(r.delta)} <span class="ml-1 text-xs text-slate-500">${arrow(r.delta)}</span></td>
        <td class="px-3 py-2 align-top">${sBadge}</td>
      </tr>`;
  }).join('');
}

// ---------------- CSV export ----------------
function toCSV(rows){
  const header = ['question','expected_id','left_rank','left_score','right_rank','right_score','delta','left_found','right_found','status'];
  const lines = rows.map(r=>{
    const ls = scoreFrom(r,'left'); const rs = scoreFrom(r,'right');
    const status = statusOf(r);
    const cells = [
      r.question||'',
      r.expected_id||'',
      r.left_rank ?? '',
      ls==null ? '' : ls,
      r.right_rank ?? '',
      rs==null ? '' : rs,
      r.delta ?? '',
      r.left_found ?? '',
      r.right_found ?? '',
      status
    ].map(v=>{
      const s = (v??'').toString();
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    });
    return cells.join(',');
  });
  return [header.join(','), ...lines].join('\n');
}

// ---------------- main ----------------
(async function init(){
  const aSel = qs('#index-a');
  const bSel = qs('#index-b');
  const kEl = qs('#k');
  const modeSel = qs('#mode');
  const runBtn = qs('#run');
  const dlBtn = qs('#download');
  const status = qs('#status');
  const csvA = qs('#csv-a');
  const csvBWrap = qs('#csv-b-wrap');

  // deep link (?a=ixA&b=ixB&k=10&autoload=1)
  const params = new URLSearchParams(location.search);
  const aFrom = params.get('a');
  const bFrom = params.get('b');
  const kFrom = params.get('k');
  const autoload = params.get('autoload') === '1';

  try {
    const names = await fetchIndexes();
    const opts = names.map(n=>`<option value="${esc(n)}">${esc(n)}</option>`).join('') || '<option disabled>(no indexes)</option>';
    aSel.innerHTML = opts; bSel.innerHTML = opts;
    if (aFrom && names.includes(aFrom)) aSel.value = aFrom;
    if (bFrom && names.includes(bFrom)) bSel.value = bFrom;
    else if (names.length>1 && !bFrom) bSel.value = names[1];
    if (kFrom) kEl.value = kFrom;
  } catch (e) {
    status.textContent = 'Failed to load indexes: ' + e;
  }

  // CSV-B visibility (backend typically ignores separate CSV)
  modeSel.addEventListener('change', ()=> {
    const v = modeSel.value;
    csvBWrap.classList.toggle('hidden', v !== 'different');
  });
  modeSel.value='same'; csvBWrap.classList.add('hidden');

  async function runCompare(){
    const file = csvA.files?.[0];
    if (!file) { status.textContent = 'Please choose a CSV file.'; return; }
    if (!aSel.value || !bSel.value || aSel.value === bSel.value) {
      status.textContent = 'Pick two different indexes.'; return;
    }
    status.textContent = 'Running…';
    qs('#cards').innerHTML = ''; qs('#delta').innerHTML = ''; qs('#tbody').innerHTML = '';

    // shareable URL
    history.replaceState(null,'',`?${new URLSearchParams({a:aSel.value,b:bSel.value,k:kEl.value,autoload:'1'}).toString()}`);

    const fd = new FormData();
    fd.append('left_index', aSel.value);
    fd.append('right_index', bSel.value);
    fd.append('k', kEl.value);
    fd.append('file', file, file.name);
    // hybrids exist in UI but are commonly ignored by the backend:
    const ha = qs('#hybrid-a').value, hb = qs('#hybrid-b').value;
    if (ha==='true' || ha==='false') fd.append('left_hybrid', ha);
    if (hb==='true' || hb==='false') fd.append('right_hybrid', hb);

    try{
      const resp = await fetch('/api/eval_compare', { method:'POST', body: fd });
      if (!resp.ok){ status.textContent='Error: '+await resp.text(); return; }
      const data = await resp.json();

      RAW_ROWS = Array.isArray(data.results) ? data.results : [];
      renderCards(data, aSel.value, bSel.value);
      renderTable();
      status.textContent = 'OK';
    }catch(e){
      status.textContent = 'Error: ' + e.message;
    }
  }

  runBtn.addEventListener('click', runCompare);
  document.addEventListener('keydown', (e)=>{ if ((e.ctrlKey||e.metaKey) && e.key==='Enter') runCompare(); });

  // filters & sorting
  qs('#filter').addEventListener('input', renderTable);
  qs('#only_changed').addEventListener('change', renderTable);
  qs('#only_impr').addEventListener('change', renderTable);
  qs('#only_regr').addEventListener('change', renderTable);
  qsa('th.th').forEach(th=>{
    th.addEventListener('click', ()=>{
      const key = th.dataset.key;
      if (!key) return;
      SORT = { key, dir: (SORT.key===key && SORT.dir==='asc') ? 'desc' : 'asc' };
      renderTable();
    });
  });

  // CSV export
  dlBtn.addEventListener('click', ()=>{
    if (!RAW_ROWS.length){ status.textContent='Run comparison first.'; return; }
    const csv = toCSV(VIEW.length ? VIEW : RAW_ROWS);
    const blob = new Blob([csv], {type:'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download='eval_compare_diff.csv';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });

  // If deep-linked with autoload, user still must choose a CSV manually.
  if (autoload){ /* noop */ }
})();
</script>
{% endblock %}
