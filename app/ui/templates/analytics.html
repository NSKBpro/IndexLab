{% extends "base.html" %}
{% block body %}
<h1 class="text-2xl font-semibold mb-6">Index Analytics</h1>

<section class="bg-white dark:bg-slate-800 rounded-2xl border border-slate-200 dark:border-slate-700 p-6 shadow-sm">
  <!-- Controls -->
  <div class="grid lg:grid-cols-6 gap-4 items-end">
    <div class="lg:col-span-2">
      <label class="text-sm font-medium">Index</label>
      <select id="index-select" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2"></select>
    </div>
    <div>
      <label class="text-sm font-medium">Version</label>
      <select id="version-select" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2">
        <option value="">(latest)</option>
      </select>
    </div>
    <div>
      <label class="text-sm font-medium">Compare to</label>
      <select id="compare-version-select" class="mt-1 w-full rounded-xl border border-slate-300 dark:border-slate-700 bg-white dark:bg-slate-900 px-3 py-2">
        <option value="">(none)</option>
      </select>
    </div>
    <div>
      <label class="text-sm font-medium opacity-0">.</label>
      <button id="load-btn" class="w-full rounded-xl bg-brand-600 hover:bg-brand-700 text-white px-4 py-2 font-medium">Load</button>
    </div>
    <div>
      <label class="text-sm font-medium">Status</label>
      <div id="status" class="mt-1 text-sm text-slate-500">—</div>
    </div>
  </div>

  <!-- Cards -->
  <div id="cards" class="grid sm:grid-cols-2 lg:grid-cols-6 gap-4 mt-6"></div>

  <!-- Histogram (overlay capable) -->
  <div id="hist-wrap" class="mt-6 hidden">
    <div class="flex items-center justify-between mb-2">
      <h3 class="text-sm font-semibold">Length distribution</h3>
      <div id="hist-legend" class="text-xs text-slate-500"></div>
    </div>
    <div class="rounded-xl border border-slate-200 dark:border-slate-700 p-4 bg-slate-50 dark:bg-slate-900/60">
      <div id="hist" class="w-full overflow-x-auto"></div>
      <div id="hist-note" class="text-[11px] text-slate-500 mt-2"></div>
    </div>
  </div>

  <!-- Per-source breakdown + Eval metrics -->
  <div class="mt-6 grid lg:grid-cols-2 gap-4">
    <!-- Per-source -->
    <div class="rounded-xl border border-slate-200 dark:border-slate-700 p-4 bg-white dark:bg-slate-900/60">
      <div class="flex items-center justify-between mb-2">
        <h3 class="text-sm font-semibold">Per-source breakdown (rows)</h3>
        <div class="text-xs text-slate-500" id="src-hint"></div>
      </div>
      <div id="src-chart" class="w-full overflow-x-auto"></div>
      <div id="src-note" class="text-[11px] text-slate-500 mt-2"></div>
    </div>

    <!-- Eval metrics -->
    <div class="rounded-xl border border-slate-200 dark:border-slate-700 p-4 bg-white dark:bg-slate-900/60">
      <div class="flex items-center justify-between mb-2">
        <h3 class="text-sm font-semibold">Evaluation metrics</h3>
        <div class="text-xs text-slate-500" id="eval-hint"></div>
      </div>
      <dl id="eval-dl" class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm"></dl>
      <div id="eval-note" class="text-[11px] text-slate-500 mt-2"></div>
    </div>
  </div>

  <!-- Manifest -->
  <div class="mt-6 grid lg:grid-cols-2 gap-4">
    <div class="rounded-xl border border-slate-200 dark:border-slate-700 p-4 bg-white dark:bg-slate-900/60">
      <h3 class="text-sm font-semibold mb-2">Build config</h3>
      <dl id="manifest-dl" class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm"></dl>
    </div>
    <div class="rounded-xl border border-slate-200 dark:border-slate-700 p-4 bg-white dark:bg-slate-900/60">
      <div class="flex items-center justify-between mb-2">
        <h3 class="text-sm font-semibold">Raw manifest</h3>
        <div class="flex items-center gap-2">
          <button id="copy-manifest" class="text-xs rounded border px-2 py-1 hover:bg-slate-100 dark:hover:bg-slate-800">Copy JSON</button>
          <button id="export-json" class="text-xs rounded border px-2 py-1 hover:bg-slate-100 dark:hover:bg-slate-800">Export JSON</button>
        </div>
      </div>
      <pre id="manifest-json" class="text-xs whitespace-pre-wrap max-h-64 overflow-auto bg-slate-50 dark:bg-slate-900 p-3 rounded-lg"></pre>
    </div>
  </div>
</section>

<!-- Toast -->
<div id="toast" class="fixed bottom-4 left-1/2 -translate-x-1/2 hidden rounded-xl bg-slate-900 text-white px-4 py-2 shadow-lg"></div>

<script>
// ===== Basic error toast =====
window.addEventListener('error', (e) => {
  const t=document.getElementById('toast');
  if(t){ t.textContent='JS error: '+(e?.message||e); t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'),3000); }
  console.error(e);
});

// ---------- utils ----------
const qs=(s,el=document)=>el.querySelector(s);
const qsa=(s,el=document)=>[...el.querySelectorAll(s)];
const esc=(s)=> (s??'').toString().replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
const fmt=(n,dec=0)=> (n==null||isNaN(n))?'—':Number(n).toFixed(dec);
function toast(msg){ const t=qs('#toast'); t.textContent=msg; t.classList.remove('hidden'); setTimeout(()=>t.classList.add('hidden'),1400); }
function get(obj, path, dflt='—'){ try{ return path.split('.').reduce((a,k)=>a?.[k], obj) ?? dflt; }catch{ return dflt; } }
function niceDate(s){ if(!s) return ''; try{ return new Date(s).toISOString().replace('T',' ').slice(0,19)+'Z'; }catch{return s} }

// ---------- service: indexes & versions ----------
const IndexLab = {
  _cache: { idx:null, exp:0, ver:new Map() },

  async fetchIndexes(force=false){
    const now=Date.now();
    if(!force && this._cache.idx && this._cache.exp>now) return this._cache.idx;
    const r=await fetch('/api/indexes'); const j=await r.json();
    const arr=Array.isArray(j.indexes)?j.indexes:[];
    this._cache.idx=arr; this._cache.exp=now+30000; return arr;
  },

  async populateIndexSelect(el, {value=null}={}){
    const sel=(typeof el==='string')?document.querySelector(el):el;
    if(!sel) return;
    const items=await this.fetchIndexes();
    sel.innerHTML=items.map(it=>`<option value="${esc(it.index_name)}">${esc(it.index_name)}</option>`).join('')||'<option disabled>(no indexes)</option>';
    if(value && [...sel.options].some(o=>o.value===value)) sel.value=value;
    return sel.value;
  },

  async fetchVersions(indexName){
    if(!indexName) return [];
    if(this._cache.ver.has(indexName)) return this._cache.ver.get(indexName);
    const r=await fetch(`/api/versioning/${encodeURIComponent(indexName)}`);
    const j=await r.json();
    const versions=Array.isArray(j.versions)?j.versions:[];
    this._cache.ver.set(indexName, versions);
    return versions;
  },

  async populateVersionSelect(el, indexName, {value=null, includeNoneLabel='(latest)'}={}){
    const sel=(typeof el==='string')?document.querySelector(el):el;
    if(!sel) return;
    const versions=await this.fetchVersions(indexName);
    const prev=sel.value;
    sel.innerHTML = `<option value="">${includeNoneLabel}</option>` + versions.map(v=>{
      const when=v.created_at?` — ${niceDate(v.created_at)}`:'';
      return `<option value="${esc(v.version)}">v${esc(v.version)}${when}</option>`;
    }).join('');
    const desired=value||prev;
    if(desired && [...sel.options].some(o=>o.value===desired)) sel.value=desired;
  }
};

// ---------- fetchers ----------
async function fetchStats(indexName, version){
  const url=`/api/stats/${encodeURIComponent(indexName)}${version?`?version=${encodeURIComponent(version)}`:''}`;
  const r=await fetch(url);
  if(!r.ok) throw new Error(await r.text());
  return await r.json();
}
async function fetchSources(indexName, version){
  const url=`/api/sources/${encodeURIComponent(indexName)}${version?`?version=${encodeURIComponent(version)}`:''}`;
  const r=await fetch(url);
  if(!r.ok) return null;
  return await r.json();
}
async function fetchVersionMeta(indexName){
  // to read eval metrics for a version
  const r=await fetch(`/api/versioning/${encodeURIComponent(indexName)}`);
  if(!r.ok) return {versions:[]};
  return await r.json();
}

// ---------- cards ----------
function card(label, value, sub='', opts={}){
  const big = opts.big === true;
  const accent = opts.accent === true;
  return `
    <div class="rounded-xl border ${accent ? 'border-brand-300 dark:border-brand-700' : 'border-slate-200 dark:border-slate-700'} p-4 ${accent ? 'bg-brand-50 dark:bg-brand-900/20' : 'bg-white dark:bg-slate-900/60'}">
      <div class="flex items-center justify-between">
        <div class="text-xs ${accent ? 'text-brand-700 dark:text-brand-300' : 'text-slate-500'}">${esc(label)}</div>
        ${accent ? `<span class="inline-flex items-center text-[10px] px-2 py-0.5 rounded-full bg-brand-100 dark:bg-brand-800/60 border border-brand-200 dark:border-brand-700 text-brand-700 dark:text-brand-200">important</span>` : ''}
      </div>
      <div class="${big ? 'text-2xl' : 'text-xl'} font-semibold mt-1 ${accent ? 'text-brand-800 dark:text-brand-200' : ''}">${esc(value)}</div>
      ${sub?`<div class="text-[11px] ${accent ? 'text-brand-700/80 dark:text-brand-300/80' : 'text-slate-500'} mt-1">${esc(sub)}</div>`:''}
    </div>`;
}

function renderCards(primaryStats, sourceMeta){
  const chunks = primaryStats.chunks ?? primaryStats.count ?? 0;
  const uniqSources = sourceMeta && sourceMeta.sources ? Object.keys(sourceMeta.sources).length : '—';
  const totalRows = sourceMeta && sourceMeta.sources
    ? Object.values(sourceMeta.sources).reduce((a,v)=>a + (Number(v?.rows)||0), 0)
    : '—';

  const c=[];
  // Promote Rows (sum)
  c.push(card('Rows (sum)', totalRows, 'Sum of rows across all ingested files', {big:true, accent:true}));
  c.push(card('Chunks', chunks, 'Vector chunks in this index'));
  c.push(card('Avg length', fmt(primaryStats.len_avg,1), 'characters'));
  c.push(card('P95 length', fmt(primaryStats.len_p95,0), 'characters'));
  c.push(card('Max length', primaryStats.len_max ?? '—', 'characters'));
  c.push(card('Unique sources', uniqSources, 'files ingested'));

  qs('#cards').innerHTML = c.join('');
}


// ---------- histogram (overlay two versions) ----------
function normalizeHistShape(s){
  // accept {hist:{bins,counts}} or separate
  if(!s) return null;
  if (s.hist && Array.isArray(s.hist.counts)) return {bins:s.hist.bins, counts:s.hist.counts};
  if (Array.isArray(s.hist_counts)) return {bins:s.hist_bins, counts:s.hist_counts};
  if (Array.isArray(s.hist)) return {bins:s.bins, counts:s.hist};
  return null;
}

function renderOverlayHistogram(primary, compare, labels){
  const wrap=qs('#hist-wrap');
  const A=normalizeHistShape(primary);
  const B=compare ? normalizeHistShape(compare) : null;
  if(!A || !Array.isArray(A.counts) || !A.counts.length){ wrap.classList.add('hidden'); return; }
  wrap.classList.remove('hidden');

  // To overlay, normalize both to same bin count/edges (simple approach: use A’s bins and re-bucket B if needed)
  const binsA=A.bins||[];
  const countsA=A.counts||[];
  const countsB = B && Array.isArray(B.counts) ? _rebucketTo(binsA, B.bins||[], B.counts||[]) : null;

  const W=720, H=180, pad={l:28,r:10,t:8,b:24};
  const n=countsA.length;
  const wBar=Math.max(1, Math.floor((W-pad.l-pad.r)/n));
  const maxCount=Math.max(1, ...countsA, ...(countsB||[0]));
  const scaleY=(c)=> Math.round((c/maxCount)*(H-pad.t-pad.b));

  let barsA='', barsB='';
  for(let i=0;i<n;i++){
    const x=pad.l+i*wBar;
    // primary: solid fill
    const hA=scaleY(countsA[i]||0), yA=H-pad.b-hA;
    barsA+=`<rect x="${x}" y="${yA}" width="${wBar-2}" height="${hA}" rx="2" ry="2" class="fill-slate-500 dark:fill-slate-400" opacity="0.9"></rect>`;
    // compare: thinner, semi-transparent overlay
    if(countsB){
      const hB=scaleY(countsB[i]||0), yB=H-pad.b-hB;
      barsB+=`<rect x="${x+Math.max(1,Math.floor((wBar-2)*0.25))}" y="${yB}" width="${Math.max(1,Math.floor((wBar-2)*0.5))}" height="${hB}" rx="2" ry="2" class="fill-brand-600" opacity="0.55"></rect>`;
    }
  }

  // x axis ticks (4)
  let ticks='', T=4, minX=binsA?.[0] ?? 0, maxX=binsA?.[binsA.length-1] ?? 0;
  for(let i=0;i<=T;i++){
    const x=pad.l+Math.round((i/T)*(W-pad.l-pad.r));
    const val=Math.round(minX + (i/T)*(maxX-minX));
    ticks+=`<text x="${x}" y="${H-6}" text-anchor="middle" class="fill-slate-500" font-size="10">${esc(String(val))}</text>`;
  }

  qs('#hist').innerHTML = `
    <svg viewBox="0 0 ${W} ${H}" width="100%" height="${H}">
      <rect x="0" y="0" width="${W}" height="${H}" rx="8" ry="8" class="fill-transparent"></rect>
      ${barsA}
      ${barsB}
      ${ticks}
    </svg>`;

  // legend
  const parts=[labels.primary];
  if (countsB) parts.push(labels.compare);
  qs('#hist-legend').textContent = parts.filter(Boolean).join(' • ');
  qs('#hist-note').textContent = countsB ? 'Shaded bars = comparison version' : '';
}

// rebucket B into A’s bin edges (simple, linear scan)
function _rebucketTo(binsA, binsB, countsB){
  if(!binsA?.length || !binsB?.length || !countsB?.length) return null;
  const out=new Array(Math.max(0,binsA.length-1)).fill(0);
  for(let j=0;j<countsB.length;j++){
    const leftB=binsB[j], rightB=binsB[j+1] ?? binsB[j];
    const count=countsB[j]||0;
    // put the whole B bin into nearest A bin by center
    const center=Math.round((Number(leftB)+Number(rightB))/2);
    // find A index by center
    let idx=0;
    for(let i=0;i<binsA.length-1;i++){
      if(center>=binsA[i] && center<=binsA[i+1]){ idx=i; break; }
      if(center>binsA[binsA.length-1]) idx=binsA.length-2;
    }
    out[idx]+=count;
  }
  return out;
}

// ---------- per-source bars (rows) ----------
function renderSourceBars(sources){
  const box=qs('#src-chart');
  const note=qs('#src-note');
  const hint=qs('#src-hint');

  if(!sources || !Object.keys(sources).length){
    box.innerHTML='<div class="text-sm text-slate-500">No source metadata recorded.</div>';
    note.textContent=''; hint.textContent='';
    return;
  }

  const rows=Object.entries(sources).map(([file,meta])=>({file, rows: Number(meta?.rows)||0}));
  rows.sort((a,b)=>b.rows-a.rows);
  const top=rows.slice(0,12);

  const total = rows.reduce((a,r)=>a+r.rows,0);
  hint.textContent = `Top by rows • total=${total}`;

  const W=720, H=260, pad={l:160,r:10,t:10,b:20};
  const maxVal=Math.max(1, ...top.map(x=>x.rows));
  const barH=Math.max(16, Math.floor((H-pad.t-pad.b)/top.length)-4);

  let svgRows='';
  top.forEach((r,idx)=>{
    const y=pad.t+idx*(barH+4);
    const w=Math.round(((r.rows)/maxVal)*(W-pad.l-pad.r));
    svgRows+=`
      <text x="${pad.l-10}" y="${y+barH-4}" text-anchor="end" class="fill-slate-600" font-size="11">${esc(r.file)}</text>
      <rect x="${pad.l}" y="${y}" width="${Math.max(1,w)}" height="${barH}" rx="4" ry="4" class="fill-slate-600 dark:fill-slate-400"></rect>
      <text x="${pad.l + Math.max(8, w-8)}" y="${y+barH-4}" text-anchor="${w>56?'end':'start'}" class="${w>56?'fill-white':'fill-slate-700 dark:fill-slate-200'}" font-size="11" font-weight="600">${esc(String(r.rows))}</text>
    `;
  });

  box.innerHTML = `<svg viewBox="0 0 ${W} ${H}" width="100%" height="${H}">${svgRows}</svg>`;
  note.textContent='Rows approximate table/document line counts; larger values indicate heavier sources.';
}


// ---------- manifest ----------
function renderManifest(stats){
  const man = stats.manifest || {
    model:  stats.model,
    dim:    stats.dim,
    backend:stats.backend,
    normalize_embeddings: stats.normalize ?? stats.normalize_embeddings,
    chunk_mode:    stats.chunking?.mode ?? stats.chunk_mode,
    chunk_size:    stats.chunking?.size ?? stats.chunk_size,
    chunk_overlap: stats.chunking?.overlap ?? stats.chunk_overlap,
    created_at:    stats.created_at
  };

  const dl=qs('#manifest-dl');
  const rows=[
    ['Model', man.model],
    ['Dim', man.dim],
    ['Backend', man.backend],
    ['Normalize embeddings', (man.normalize_embeddings!=null ? String(man.normalize_embeddings) : '—')],
    ['Chunk mode', man.chunk_mode],
    ['Chunk size', man.chunk_size],
    ['Chunk overlap', man.chunk_overlap],
    ['Created at', man.created_at],
  ];
  dl.innerHTML = rows.map(([k,v])=>`
    <dt class="text-xs text-slate-500">${esc(k)}</dt>
    <dd class="text-sm font-medium">${esc(v ?? '—')}</dd>
  `).join('');

  const raw = JSON.stringify(man, null, 2);
  qs('#manifest-json').textContent = raw;

  qs('#copy-manifest').onclick = async ()=>{ try{ await navigator.clipboard.writeText(raw); toast('Manifest copied'); }catch{ toast('Copy failed'); } };
  qs('#export-json').onclick = ()=>{
    const blob = new Blob([JSON.stringify({stats, manifest:man}, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`index_stats_${(stats.index_name||'index')}${stats.version?`_v${stats.version}`:''}.json`;
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  };
}

// ---------- eval metrics ----------
function renderEvalMetrics(indexName, version, allVersions){
  const dl=qs('#eval-dl');
  const hint=qs('#eval-hint');
  const note=qs('#eval-note');
  const rec = (allVersions?.versions||[]).find(v => v.version===version) || null;

  const val = (x)=> (x==null || Number.isNaN(Number(x)) ? '—' : String(x));

  const rows = [
    ['Recall@k', rec?.metrics?.['recall@k']],
    ['MRR',      rec?.metrics?.mrr],
    ['nDCG',     rec?.metrics?.ndcg],
    ['Build id', rec?.build_id],
    ['Created',  rec?.created_at ? niceDate(rec.created_at) : '—'],
    ['Notes',    rec?.notes ?? '—'],
  ];
  dl.innerHTML = rows.map(([k,v])=>`
    <dt class="text-xs text-slate-500">${esc(k)}</dt>
    <dd class="text-sm font-medium">${esc(val(v))}</dd>
  `).join('');

  hint.textContent = version ? `v${version}` : '(latest has no version metrics)';
  note.textContent = rec ? '' : 'No metrics found for this version.';
}

// ---------- init ----------
(async function init(){
  const sel = qs('#index-select');
  const ver = qs('#version-select');
  const cmp = qs('#compare-version-select');
  const status = qs('#status');
  const btn = qs('#load-btn');

  const params=new URLSearchParams(location.search);
  const idxFromUrl=params.get('index');
  const verFromUrl=params.get('version');
  const cmpFromUrl=params.get('compare');

  try{
    await IndexLab.populateIndexSelect(sel, {value: idxFromUrl});
    await IndexLab.populateVersionSelect(ver, sel.value, {value: verFromUrl, includeNoneLabel:'(latest)'});
    await IndexLab.populateVersionSelect(cmp, sel.value, {value: cmpFromUrl, includeNoneLabel:'(none)'});
  }catch(e){ status.textContent='Init failed: '+e; }

  sel.addEventListener('change', async ()=>{
    await IndexLab.populateVersionSelect(ver, sel.value, {includeNoneLabel:'(latest)'}); 
    await IndexLab.populateVersionSelect(cmp, sel.value, {includeNoneLabel:'(none)'}); 
    status.textContent='Index changed. Click “Load”.';
  });

  btn.addEventListener('click', load);
  document.addEventListener('keydown', (e)=>{ if((e.ctrlKey||e.metaKey)&&e.key==='Enter') btn.click(); });

  // autoload if any value present
  if(sel.value) load();

  async function load(){
    const ix = sel.value;
    const v  = ver.value || '';
    const w  = cmp.value || '';

    if(!ix){ status.textContent='Pick an index'; return; }
    status.textContent='Loading…';
    qs('#cards').innerHTML='';
    qs('#hist-wrap').classList.add('hidden');
    qs('#manifest-dl').innerHTML='';
    qs('#manifest-json').textContent='';
    qs('#src-chart').innerHTML='';
    qs('#src-hint').textContent='';
    qs('#eval-dl').innerHTML='';
    qs('#eval-hint').textContent='';

    // deep link
    const p=new URLSearchParams({index:ix, autoload:'1'});
    if(v) p.set('version', v);
    if(w) p.set('compare', w);
    history.replaceState(null, '', `?${p.toString()}`);

    try{
      const [primary, compare, sources, allVers] = await Promise.all([
        fetchStats(ix, v),
        w ? fetchStats(ix, w) : Promise.resolve(null),
        fetchSources(ix, v),
        fetchVersionMeta(ix),
      ]);

      // Cards
      renderCards(primary, sources);

      // Histogram overlay
      renderOverlayHistogram(primary, compare, {
        primary: v ? `v${v}` : 'latest',
        compare: w ? `v${w}` : null
      });
      qs('#hist-note').textContent = 'Chunk length is measured in characters. Use this distribution to sanity-check chunking.';
      // Per-source bars (rows)
      renderSourceBars(sources?.sources || {});
      qs('#src-hint').textContent = v ? `v${v}` : 'latest';

      // Eval metrics (from versioning API)
      renderEvalMetrics(ix, v || '', allVers);

      // Manifest
      renderManifest(primary);

      status.textContent='OK';
    }catch(e){
      status.textContent='Error: '+e.message;
    }
  }
})();
</script>
{% endblock %}
